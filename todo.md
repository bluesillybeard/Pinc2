# Plans and TODOs

## Next Steps / Roadmap
- implement the rest of SDL2 + OpenGl backend
    - add tests as things are implemented
- Make sure all of the important TODOs are handled
- create pinc graphics
    - Just base it off the original one.
    - Changes I want to make:
        - move the texture sampling properties from the uniform to the pipeline
        - More dynamic pipeline state
        - Remove GLSL and use a custom shader definition compatible with fixed function rendering (aim for minimal features like OpenGL 1.0 or the N64)
        - Add GLSL as an optional feature that a graphics backend may or may not have
        - Add indexed framebuffer / texture (where colors are an enum instead of brightness values)
            - This may be as simple as adding a new color space and some query functions.
            - Note: Modern APIs don't support this directly (lol I wonder why), so this capability needs to be queryable
            - SDL2 supports this! I'm genuinely not quite sure why they would, seeing as they only target platforms of the last ~20 years, but still neat.
        - scissor rectangle
        - add framebuffer objects / arbitrary draw surfaces
            - many APIs do not support these so they must be optional to implement
            - With that said, on the OpenGL 1.1 - 2.1 side, ARB_framebuffer_object or EXT_framebuffer_object are apparently widely supported, and almost guaranteed on 2.x hardware.
        - queue based rendering - the user makes a queue, submits all of it at once, and can query if it's finished or not.
            - Not so nice in OpenGL land, which does all of the sync automatically, but this is a nice abstraction that many other APIs can benefit from.
                - Note: Look at OpenGL sync objects, ARB_sync, NV_fence.
                - Note: Look into NV_command_list, also ARB_shader_draw_parameters may be useful
    - set up interface for graphics backend
    - implement opengl 2.1 backend
- implement the rest of the examples from the original project
    - Remove the link to the old Zig version
- Celebrate! we've made it back to where we left off in the original Zig version of Pinc.
    - And in fact, with some new things that the original prototype-like thing did not have
- implement many examples, inspired from the likes of SDL and GLFW
- proper documentation to guide users on how to use this library

## TODO for API features / changes
- better text selection input. ex: SDL_TextSelectionEvent
- Clipboard
    - text is already done
    - arbitrary data / MIME types
        - Not supported by any of the current backends! This means we're going to need a backend that even has the concept of a non-text clipboard before implementing this into the API
            - OK but seriously, did it really take until the after SDL2 was 'finished' for arbitrary clipboard MIME types to be implemented? They even have it for drag & drop!
- Drag & Drop
    - arbitrary data / MIME types
- window position
    - wayland be like:
    - In fact, there are many potential platforms that don't support window positioning:
        - Pretty much any console
        - Emscripten / web canvas
        - applets
        - Window positioning will likely have to be optional
- querying monitor / display configuration
    - xinerama mentioned?
- lots of events aren't implemented yet
- ability get data from specific backends
    - X display, X windows, SDL2 opengl context, Win32 window handle, etc etc etc
- backend-specific settings
- ability to use backend objects to create Pinc objects
    - example: init pinc's X backend with an X Display, or a window with an X window handle, etc.
- general input methods
    - controller / gamepad
    - touch screen
    - drawing tablet
    - VR headsets
        - every headset seems to have its own position / velocity system...
- HDR support
    - Admittedly, it seems HDR support is still in the early stages on anything other than Windows...
- Ability to get system theme colors and name
    - Probably pretty easy on Windows
    - Does MacOS even have themes?
    - good luck doing this on Linux lol
        - GNOME
        - KDE Plasma
        - Cosmic
        - XFCE
        - AwesomeWM
        - Sway
        - Cinnamon
        - Budgie
        - Mate
        - ... and a billion more, although most of the current smaller ones will likely die along with X11
        - could probably just read the GTK and QT system themes and get 99% coverage
        - I think recently a portal and standard for cross-toolkit theming was created
    - Most consoles don't even have user-defined coloring, so those can be hard-coded
- Audio support
    - audio playback to a default or specific device
    - software audio, or something like (the ancient and probably deprecated) OpenAL which supports hardware acceleration
    - directly output samples
    - audio recording
    - arbitrary inputs and outputs for something like DAW software
        - ability to check the system's ability to handle multiple inputs / multiple outputs
        - notify the application when the user edits the audio output through system settings or something like qpwgraph
    - native implementations for OpenAL, ALSA, pipewire, and whatever else?
        - SDL backend probably
- built-in text / font rendering
    - This is an extremely common thing to do, so it may make sense to just add this into Pinc directly - maybe an official (but separate) module?
    - Would we want to do only basic text (ASCII), a partial implementation of unicode (ex: FreeType), or a full text shaping engine (ex: HarfBuz)?
- Add option to capture mouse and lock mouse
    - Capture mouse just forces it to be in the window. As much as I hate this as a user, may as well just add it for completeness.
    - Lock mouse forces it to be in the window, and is used for first-person games for camera movement, and sometimes by applications (like Blender) to have infinite mouse movement for certain operations (like changing unbounded sliders or panning the camera).
- header option to only include types and not functions
- Potentially allow a different framebuffer format for each window
- binding policy
    - how bindings to new languages should be handled, maintained, etc.
    - building the library and shipping the .so for dynamic languages, integrating with the build system of native languages, etc.
- expose the Pinc temp allocator for user convenience
- Allow a different graphics API per window
    - Maybe even completely separate the idea of a graphics API and a window, like what SDL2 somewhat does
    - Probably wait until more than just OpenGL is supported
- Change window states to an enum instead of a bunch of sorta-implicitly-exclusive bools
- add window state change events
- OpenGL Release Behavior
- OpenGL reset notification
- OpenGL floatbuffers
- OpenGL optional double buffering
    - I don't know who wants this to be honest, maybe wait for a PR as (afaik) many APIs don't even support this kind of operation anymore
- option for an amalgamated "build" (so pack the entirety of Pinc into a single .c and .h file)

## TODO for internal library
- always recoverable errors
    - In effect, on any error of any kind, there should be a valid return path to the caller with a signal that an error occurred
- replace tscoding/areana with custom implementation
- Add unit tests for certain functions
    - *cough cough* bufPrint\* *cough cough*
- add debug print system with proper formatting (that isn't just a copy of libc's formatting)
    - Partially done, but it should be more ergonomic and have the ability to call into a user function
- expose (most of) platform.h so users can write code that is just as portable as Pinc itself while not giving up features that libc doesn't have
- Add options / code / auto detection for where libraries come from
    - This is a requirement for supporting platforms without dynamic linking (such as the web)
- set up clang-tidy or another linter
- allocation tracking
- More build systems
    - scons
    - premake
    - GNU make
    - nix
    - meson?
    - autoconf?
- linking / using ANGLE for better macos+opengl support, among other improvements to OpenGL
- Add generation info to object handles
- Option to window interface and directly link when there is only one window interface enabled
    - This removes not only a layer of wrappers, but also a layer of indirection and a (potentially) decent amount of memory use as well
- Set up proper automated pass/fail testing
    - Automated pass/fail tests
    - All events
    - memory safety (fsanitize + valgrind)
    - Every function
    - fuzzers
    - error propagation
    - mock window backend
    - validation window backend
